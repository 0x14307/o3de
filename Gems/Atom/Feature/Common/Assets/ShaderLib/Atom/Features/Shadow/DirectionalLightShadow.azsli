/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

#include <scenesrg.srgi>
#include <viewsrg.srgi>
#include <Atom/RPI/Math.azsli>
#include "Shadow.azsli"
#include "ShadowmapAtlasLib.azsli"
#include "BicubicPcfFilters.azsli"
#include "ReceiverPlaneDepthBias.azsli"
#include "NormalOffsetShadows.azsli"



// DirectionalLightShadow calculates lit ratio for a directional light.
class DirectionalLightShadow
{
    struct DebugInfo
    {
        uint m_cascadeIndex; // cascade index where lit ratio determined.
        bool m_usePcfFallback;
    };

    //////////
    // public method

    //! This calculates the shadow coordinate for each cascade.
    //! This can be called from vertex shaders.
    //! @param lightIndex directional light index.
    //! @param worldPosition position of the surface in the world space.
    //! @param shadowCoords calculated shadow coordinates.
    static float ChooseClosest(float visDepth[5], float myDepth);
    static float ChooseDimmest(float visDepth[5], float myDepth);
    static float ChooseWeighted(float visDepth[5], float myDepth);

    //! This calculates visibility ratio of the surface from the light origin.
    //! This should be called from fragment shaders.
    //! @param lightIndex directional light index.
    //! @param shadowCoords shadow coordinates of the surface for each cascade.
    //! @param normalVector normal vector of the surface in world space.
    //! @param debugInfo information used in debug coloring.
    //! @return lit ratio from the light (1.0 is fully visible).
    static float GetVisibility(
        uint lightIndex,
        float3 normalVector,
        float4 screenUv,
        out DebugInfo debugInfo);

    static float GetThickness(uint lightIndex, float3 shadowCoords[ViewSrg::MaxCascadeCount]);

    //! This alters the input color to visualize which cascade is being used
    //! and whether PCF is used as a fallback in ESM+PCF mode or not.
    //! @param color input color.
    //! @param lightIndex directional light index.
    //! @param debugInfo information of used cascade and PCF is used in ESM+PCF mode.
    //! @return resulting color.
    static float3 AddDebugColoring(
        float3 color, 
        uint lightIndex,
        DebugInfo debugInfo);

    //////////
    // private methods

    // This checks if the point from the given coordinate is shadowed or not.
    // result.x == true if the shadowCoord falls within the cascade.
    // result.y == true if the given coordinate is in shadow.
    bool2 IsShadowed(float3 shadowCoord, uint indexOfCascade);

    // This outputs visibility ratio (from 0.0 to 1.0) of the given coordinate
    // from the light origin without filtering.
    float GetVisibilityFromLightNoFilter();

    // This outputs visibility ratio (from 0.0 to 1.0) for PCF.
    float GetVisibilityFromLightPcf();

    // This outputs visibility ratio (from 0.0 to 1.0) for ESM.
    float GetVisibilityFromLightEsm();

    // This outputs visibility ratio (from 0.0 to 1.0) for ESM+PCF.
    float GetVisibilityFromLightEsmPcf();

    float SamplePcfBicubic(float3 shadowCoord, uint indexOfCascade);

    float CalculateCascadeBlendAmount(const float3 texCoord);

    uint m_lightIndex;
    float3 m_shadowCoords[ViewSrg::MaxCascadeCount];
    float m_slopeBias[ViewSrg::MaxCascadeCount];
    float3 m_normalVector;
    DebugInfo m_debugInfo;
    float3 m_shadowPosDX[ViewSrg::MaxCascadeCount];
    float3 m_shadowPosDY[ViewSrg::MaxCascadeCount];
};



float DirectionalLightShadow::GetThickness(uint lightIndex, float3 shadowCoords[ViewSrg::MaxCascadeCount])
{
    static const float PixelMargin = 1.5; // avoiding artifact between cascade levels.
    static const float DepthMargin = 1e-8; // avoiding artifact when near depth bounds.

    const uint size = ViewSrg::m_directionalLightShadows[lightIndex].m_shadowmapSize;
    if (size <= 1)
    {
        return 0.;
    }

    Texture2DArray<float> shadowmap = PassSrg::m_directionalLightShadowmap;
    const uint cascadeCount = ViewSrg::m_directionalLightShadows[lightIndex].m_cascadeCount;
    
    float3 shadowCoord;
    for (uint indexOfCascade = 0; indexOfCascade < cascadeCount; ++indexOfCascade)
    {  
        shadowCoord = shadowCoords[indexOfCascade];
        if (shadowCoord.x >= 0. && shadowCoord.x * size < size - PixelMargin &&
             shadowCoord.y >= 0. && shadowCoord.y * size < size - PixelMargin && shadowCoord.z < (1. - DepthMargin))
        {
            const float depthBufferValue = shadowmap.Sample(PassSrg::LinearSampler, float3(shadowCoord.xy, indexOfCascade)).r;
            const float deltaDepth = abs(shadowCoord.z - depthBufferValue);
            const float viewSpaceThickness = ViewSrg::m_directionalLightShadows[lightIndex].m_far_minus_near * deltaDepth;            
            return viewSpaceThickness;
        }
    }
    
    return 0.;
}


float DirectionalLightShadow::ChooseClosest(float visDepth[5], float myDepth)
{
    return 1;
/*
    int best = 0;
    for(int i = 1 ; i < 5 ; ++i)
    {
        float compDepth = abs(myDepth - visDepth[i].g);
        float bestDepth = abs(myDepth - visDepth[best].g);
        if (compDepth < bestDepth)
        {
            best = i;
        } 
    }
    return visDepth[best].r;*/
}

float DirectionalLightShadow::ChooseDimmest(float visDepth[5], float myDepth)
{
    float res = visDepth[0];
    for(int i = 1 ; i < 5 ; ++i)
    {
        if (res > visDepth[i])
        {
            res = visDepth[i];
        }
    }
    return res;
}

float DirectionalLightShadow::ChooseWeighted(float visDepth[5], float viewSpaceDepth)
{
    return 1;
    /*

    int i;
    
    float largestDiff = 0;
    for(i = 0 ; i < 5 ; ++i)
    {
        float d = abs(visDepth[i].g - viewSpaceDepth);
        largestDiff = max(largestDiff, d);
    }
    
        
    float totW = 0; 
    float res = 0;
    for(i = 0 ; i < 5 ; ++i)
    {
        const float constantToAvoidZeroWeight = 0.01; // divide by zero possible without this
        float w = saturate(largestDiff - abs(visDepth[i].g - viewSpaceDepth));
        if (i==0)
        {
            w += 0.01;
        }

        w = w*w;        
        res += visDepth[i].r * w;
        totW += w;
    }  
    res /= totW;
    return res;*/
}


float DirectionalLightShadow::GetVisibility(
    uint lightIndex,
    float3 normalVector,
    float4 screenUv,
    out DirectionalLightShadow::DebugInfo debugInfo)
{ 
    debugInfo.m_cascadeIndex = 0;
    debugInfo.m_usePcfFallback = false;    
    
    uint fullScreenShadowWidth, fullScreenShadowHeight;
    PassSrg::m_fullscreenShadow.GetDimensions(fullScreenShadowWidth, fullScreenShadowHeight);
    const float2 normScreenUv = screenUv.xy / float2(fullScreenShadowWidth, fullScreenShadowHeight);

    
    const float viewSpaceDepth = abs(screenUv.w);
    
    float visDepth[5];
    visDepth[0] = PassSrg::m_fullscreenShadow.Load(int3(screenUv.xy, 0)).x;
    visDepth[1] = PassSrg::m_fullscreenShadow.Load(int3(screenUv.xy + int2(1,0), 0)).x;
    visDepth[2] = PassSrg::m_fullscreenShadow.Load(int3(screenUv.xy + int2(0,1), 0)).x;
    visDepth[3] = PassSrg::m_fullscreenShadow.Load(int3(screenUv.xy + int2(-1,0), 0)).x;
    visDepth[4] = PassSrg::m_fullscreenShadow.Load(int3(screenUv.xy + int2(0,-1), 0)).x;
    return ChooseDimmest(visDepth, viewSpaceDepth);    
}

float3 DirectionalLightShadow::AddDebugColoring(
    float3 color, 
    uint lightIndex, 
    DirectionalLightShadow::DebugInfo debugInfo)
{
    const uint cascadeIndex = debugInfo.m_cascadeIndex;
    const bool usePcfFallback = debugInfo.m_usePcfFallback;
    const uint cascadeCount = ViewSrg::m_directionalLightShadows[lightIndex].m_cascadeCount;

    if ((ViewSrg::m_directionalLightShadows[lightIndex].m_debugFlags &
        ViewSrg::DirectionalLightShadowDebugColoringBitMask) == 0)
    {
        return color;
    }
    if (usePcfFallback)
    {
        return float3(1, 0, 1);
    }

    if (cascadeIndex < cascadeCount)
    {
        static const float3 debuggingColors[ViewSrg::MaxCascadeCount] = 
        {
            float3(1., 0., 0.), 
            float3(0., 1., 0.), 
            float3(0., 0., 1.), 
            float3(1., 1., 0.)};
        color = color * 0.75 + debuggingColors[cascadeIndex] * 0.25;
    }
    return color;
}

