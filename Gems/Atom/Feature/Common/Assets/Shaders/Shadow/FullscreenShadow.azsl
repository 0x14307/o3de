/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */



#include <Atom/Features/SrgSemantics.azsli>

#include <Atom/Features/PostProcessing/FullscreenPixelInfo.azsli>
#include <Atom/Features/PostProcessing/FullscreenVertex.azsli>
#include <Atom/Features/PostProcessing/PostProcessUtil.azsli>
#include <Atom/Features/ScreenSpace/ScreenSpaceUtil.azsli>
#include <Atom/Features/Shadow/NormalOffsetShadows.azsli>
#include <Atom/Features/Shadow/BicubicPcfFilters.azsli>
#include <Atom/Features/Shadow/Shadow.azsli>
#include <Atom/RPI/Math.azsli>
#include <viewsrg.srgi>

enum ShadowFilterMethod
{
    ShadowFilterMethod_None = 0,
    ShadowFilterMethod_Pcf = 1,
    ShadowFilterMethod_Esm = 2,
    ShadowFilterMethod_EsmPcf = 3
};

static const float CascadeBlendArea = 0.015f; // might be worth exposing this as a slider.

ShaderResourceGroup PassSrg : SRG_PerPass
{
    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
    };

    // Hardware PCF comparison sampler that is used when sampling the shadow maps
    SamplerComparisonState m_hwPcfSampler
    {
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
        MagFilter = Linear;
        MinFilter = Linear;
        MipFilter = Point;
        ComparisonFunc = Less;
        MaxAnisotropy = 16;
        ReductionType = Comparison;
    };    
    
    struct Constants
    {
        float2 m_screenSize;
        int m_filterMode;
        int m_blendBetweenCascadesEnable;        
        int m_receiverShadowPlaneBiasEnable;
        int3 m_padding;
    };    
    
    Constants m_constantData;
    Texture2DArray<float> m_directionalLightShadowmap;   
    Texture2DArray<float> m_directionalLightExponentialShadowmap;    
    Texture2D<float> m_depth;
}

#include <Atom/RPI/ShaderResourceGroups/DefaultDrawSrg.azsli>

class DirectionalLightShadow
{
    struct DebugInfo
    {
        uint m_cascadeIndex; // cascade index where lit ratio determined.
        bool m_usePcfFallback;
    };

    // This outputs the coordinate in shadowmap Texture space of the given point.
    void ComputeShadowCoords(
        uint lightIndex,
        float3 worldPosition,
        float3 worldNormal)
    {
        const float shadowBias = ViewSrg::m_directionalLightShadows[lightIndex].m_shadowBias;

        const float4x4 lightViewToShadowmapMatrices[ViewSrg::MaxCascadeCount] = ViewSrg::m_directionalLightShadows[lightIndex].m_lightViewToShadowmapMatrices;
        const float4x4 worldToLightViewMatrices[ViewSrg::MaxCascadeCount] = ViewSrg::m_directionalLightShadows[lightIndex].m_worldToLightViewMatrices;

        const uint cascadeCount = ViewSrg::m_directionalLightShadows[lightIndex].m_cascadeCount;
        const float3 shadowOffset = ComputeNormalShadowOffset(ViewSrg::m_directionalLightShadows[lightIndex].m_normalShadowBias, worldNormal, ViewSrg::m_directionalLightShadows[lightIndex].m_shadowmapSize);

        for (uint index = 0; index < cascadeCount; ++index)
        {        
            float4 lightSpacePos = mul(worldToLightViewMatrices[index], float4(worldPosition + shadowOffset, 1.));
            lightSpacePos.z += shadowBias;
            
            const float4 clipSpacePos = mul(lightViewToShadowmapMatrices[index], lightSpacePos);                
            m_shadowCoords[index] = clipSpacePos.xyz / clipSpacePos.w;
        }
                
        if (PassSrg::m_constantData.m_receiverShadowPlaneBiasEnable)
        {
            [unroll]
            for(int i = 0 ; i < ViewSrg::MaxCascadeCount ; ++i)
            {
                m_shadowPosDX[i] = ddx_fine(m_shadowCoords[i]);
                m_shadowPosDY[i] = ddy_fine(m_shadowCoords[i]);        
            }    
        }        
    }



    bool2 IsShadowed(float3 shadowCoord, uint indexOfCascade)
    {
        static const float PixelMargin = 1.5; // avoiding artifact between cascade levels.
        static const float DepthMargin = 1e-8; // avoiding artifact when near depth bounds.

        // size is the shadowap's width and height.
        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;

        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        Texture2DArray<float> shadowmap = PassSrg::m_directionalLightShadowmap;

        [branch]
        if (shadowCoord.x >= 0. && shadowCoord.x * size < size - PixelMargin &&
            shadowCoord.y >= 0. && shadowCoord.y * size < size - PixelMargin)
        {
            const float3 coord = float3(shadowCoord.xy, indexOfCascade);
            const float depthInShadowmap = shadowmap.Sample(PassSrg::LinearSampler, coord).r;
            // Test the case where the shadowed pixel is nearer than the maximal depth
            // of the cascade.  Otherwise, escalate the next cascade.
            if (shadowCoord.z < 1. - DepthMargin)
            {
                const float depthDiff = shadowCoord.z - depthInShadowmap;
                return bool2(true, (depthDiff > m_slopeBias[indexOfCascade]));
            }
        }
        return bool2(false, false);
    }
    
    float GetVisibility()
    {
        float lit = 1;
        switch(PassSrg::m_constantData.m_filterMode)
        {
            case ShadowFilterMethod_None:
                lit = GetVisibilityFromLightNoFilter();
                break;
            case ShadowFilterMethod_Pcf:
                lit = GetVisibilityFromLightPcf();
                break;
            case ShadowFilterMethod_Esm:
                lit = GetVisibilityFromLightEsm();
                break;
            case ShadowFilterMethod_EsmPcf:
                lit = GetVisibilityFromLightEsmPcf();
                break;
        }
                    
        return lit;
    }
    
    float GetVisibilityFromLightNoFilter()
    {       
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        for (uint indexOfCascade = 0; indexOfCascade < cascadeCount; ++indexOfCascade)
        {
            const bool2 checkedShadowed = IsShadowed(
                m_shadowCoords[indexOfCascade],
                indexOfCascade);
            if (checkedShadowed.x)
            {
                m_debugInfo.m_cascadeIndex = indexOfCascade;
                return checkedShadowed.y ? 0. : 1.;
            }
        }
        m_debugInfo.m_cascadeIndex = cascadeCount;
        return 1.;
    }    

    float SamplePcfBicubic(float3 shadowCoord, uint indexOfCascade)
    {
        const uint filteringSampleCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_filteringSampleCount;
        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;
        
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        Texture2DArray<float> shadowmap = PassSrg::m_directionalLightShadowmap;

        SampleShadowMapBicubicParameters param;
        param.shadowMap = shadowmap;
        param.shadowPos = float3(shadowCoord.xy, indexOfCascade);
        param.shadowMapSize = size;
        param.invShadowMapSize = rcp(size); 
        param.comparisonValue = shadowCoord.z;
        param.samplerState = PassSrg::m_hwPcfSampler;
        param.receiverPlaneDepthBias = PassSrg::m_constantData.m_blendBetweenCascadesEnable ? ComputeReceiverPlaneDepthBias(m_shadowPosDX[indexOfCascade], m_shadowPosDY[indexOfCascade]) : 0;
        
        [branch]     
        if (filteringSampleCount <= 4)       
        {
            return SampleShadowMapBicubic_4Tap(param);
        }
        else if (filteringSampleCount <= 9)
        {
            return SampleShadowMapBicubic_9Tap(param);
        }
        else
        {
            return SampleShadowMapBicubic_16Tap(param);
        }
    }
     
    float GetVisibilityFromLightPcf()
    {   
        static const float PixelMargin = 1.5; // avoiding artifact between cascade levels.
        static const float DepthMargin = 1e-8; // avoiding artifact when near depth bounds.

        bool cascadeFound = false;
        int currentCascadeIndex = 0;

        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        for (uint indexOfCascade = 0; indexOfCascade < cascadeCount; ++indexOfCascade)
        {
            const float3 shadowCoord = m_shadowCoords[indexOfCascade];
            
            if (shadowCoord.x >= 0. && shadowCoord.x * size < size - PixelMargin &&
                shadowCoord.y >= 0. && shadowCoord.y * size < size - PixelMargin && 
                shadowCoord.z < 1. - DepthMargin)
            {
                currentCascadeIndex = m_debugInfo.m_cascadeIndex = indexOfCascade;
                cascadeFound = true;
                break;
            }
        }

        [branch]
        if (cascadeFound)
        {
            float lit = SamplePcfBicubic(m_shadowCoords[currentCascadeIndex], currentCascadeIndex);
            
            if(PassSrg::m_constantData.m_blendBetweenCascadesEnable) 
            {  
                const float blendBetweenCascadesAmount = CalculateCascadeBlendAmount(m_shadowCoords[currentCascadeIndex].xyz);

                const int nextCascadeIndex = currentCascadeIndex + 1;
                [branch]
                if (blendBetweenCascadesAmount < 1.0f && nextCascadeIndex < cascadeCount)
                {
                    const float nextLit = SamplePcfBicubic(m_shadowCoords[nextCascadeIndex], nextCascadeIndex);
                    lit = lerp(nextLit, lit, blendBetweenCascadesAmount);             
                }
            } 

            return lit;
        }

        m_debugInfo.m_cascadeIndex = cascadeCount;
        return 1.;
    } 
            
    float GetVisibilityFromLightEsm()
    {
        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        Texture2DArray<float> shadowmap = PassSrg::m_directionalLightShadowmap;
        Texture2DArray<float> expShadowmap = PassSrg::m_directionalLightExponentialShadowmap;

        for (uint indexOfCascade = 0; indexOfCascade < cascadeCount; ++indexOfCascade)
        {
            const float3 shadowCoord = m_shadowCoords[indexOfCascade];
            const float distanceMin = ViewSrg::m_esmsDirectional[indexOfCascade].m_lightDistanceOfCameraViewFrustum;
            bool2 checkedShadowed = IsShadowed(shadowCoord, indexOfCascade);
            const float depthDiff = shadowCoord.z - distanceMin;
        
            [branch]
            if (checkedShadowed.x && depthDiff >= 0)
            {
                const float distanceWithinCameraView = depthDiff / (1. - distanceMin);
                const float3 coord = float3(shadowCoord.xy, indexOfCascade);
                const float occluder = expShadowmap.Sample(PassSrg::LinearSampler, coord).r;                        
                const float exponent = -EsmExponentialShift * (distanceWithinCameraView - occluder);
                const float ratio = exp(exponent);

                m_debugInfo.m_cascadeIndex = indexOfCascade;
                return saturate(ratio);
            }
        }

        m_debugInfo.m_cascadeIndex = cascadeCount;
        return 1.;
    }
    
    float GetVisibilityFromLightEsmPcf()
    {
        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        Texture2DArray<float> shadowmap = PassSrg::m_directionalLightShadowmap;
        Texture2DArray<float> expShadowmap = PassSrg::m_directionalLightExponentialShadowmap;

        for (uint indexOfCascade = 0; indexOfCascade < cascadeCount; ++indexOfCascade)
        {
            const float3 shadowCoord = m_shadowCoords[indexOfCascade];
            const float distanceMin = ViewSrg::m_esmsDirectional[indexOfCascade].m_lightDistanceOfCameraViewFrustum;
            bool2 checkedShadowed = IsShadowed(shadowCoord, indexOfCascade);
            const float depthDiff = shadowCoord.z - distanceMin;
        
            [branch]
            if (checkedShadowed.x && depthDiff >= 0)
            {
                const float distanceWithinCameraView = depthDiff / (1. - distanceMin);
                const float3 coord = float3(shadowCoord.xy, indexOfCascade);
                const float occluder = expShadowmap.Sample(PassSrg::LinearSampler, coord).r;
                const float exponent = -EsmExponentialShift * (distanceWithinCameraView - occluder);
                float ratio = exp(exponent);

                static const float pcfFallbackThreshold = 1.04;
                if (ratio > pcfFallbackThreshold)
                {
                    m_debugInfo.m_usePcfFallback = true;
                    ratio = GetVisibilityFromLightPcf();
                }
                else
                {
                    m_debugInfo.m_usePcfFallback = false;
                }
                m_debugInfo.m_cascadeIndex = indexOfCascade;
                return saturate(ratio);
            }
        }

        m_debugInfo.m_usePcfFallback = false;
        m_debugInfo.m_cascadeIndex = cascadeCount;
        return 1.;
    }

    float CalculateCascadeBlendAmount(const float3 texCoord)
    {
        const float distanceToOneMin = min3(1.0f - texCoord);
        const float currentPixelsBlendBandLocation = min(min(texCoord.x, texCoord.y), distanceToOneMin);
        return currentPixelsBlendBandLocation / CascadeBlendArea;
    }
    
    float3 m_shadowCoords[ViewSrg::MaxCascadeCount];
    float m_slopeBias[ViewSrg::MaxCascadeCount];
    float3 m_shadowPosDX[ViewSrg::MaxCascadeCount];
    float3 m_shadowPosDY[ViewSrg::MaxCascadeCount];
    uint m_lightIndex;
    DebugInfo m_debugInfo;    
};





PSOutput MainPS(VSOutput IN)
{
    DirectionalLightShadow directionalLightShadow;

    const uint lightIndex = 0;
    float3 coord = 0;
    const float shadowBias = ViewSrg::m_directionalLightShadows[lightIndex].m_shadowBias;
    const float zDepth = PassSrg::m_depth.Sample(PassSrg::LinearSampler, IN.m_texCoord);

    float3 surfacePosWS = WorldPositionFromDepthBuffer(PassSrg::m_constantData.m_screenSize, zDepth, IN.m_position.xy).xyz;
    
    const float3 worldNormal = float3(0,0,1);
    
    directionalLightShadow.ComputeShadowCoords(lightIndex, surfacePosWS, worldNormal);
   
 
    PSOutput OUT;   
    OUT.m_color.rgb = directionalLightShadow.GetVisibility();
    return OUT; 
}


