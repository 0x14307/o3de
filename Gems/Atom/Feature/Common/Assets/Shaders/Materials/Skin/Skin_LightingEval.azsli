/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

// This #define magic lets you use the EvaluateLighting function in this file without making it the final EvaluateLighting
// used in your shader. Simply #define EvaluateLighting to your custom definition before including this file
//
#ifndef EvaluateLighting
#define EvaluateLighting EvaluateLighting_SkinPBR
#endif

#include "../BasePBR/BasePBR_LightingEval.azsli"

void InitializeLightingData_SkinPBR(inout Surface surface, float4 screenPosition, float3 viewPosition, inout LightingData lightingData)
{
    // --- Base PBR ---
    InitializeLightingData_BasePBR(surface, screenPosition, viewPosition, lightingData);

    // --- Skin PBR ---

    lightingData.diffuseAmbientOcclusion = surface.diffuseAmbientOcclusion;
    lightingData.specularOcclusion = surface.specularOcclusion;

    // AKM_MARKER
    //lightingData.diffuseAmbientOcclusion = 1;
    //lightingData.specularOcclusion = 1;
}

LightingData EvaluateLighting_SkinPBR(inout Surface surface, float4 screenPosition, float3 viewPosition)
{
    // AKM_MARKER
    real3 redColor = real3(0.5, 0.0, 0.0);
    real3 blueColor = real3(0.0, 0.0, 0.5);
    real3 greenColor = real3(0.0, 0.5, 0.0);

    LightingData lightingData;
    InitializeLightingData_SkinPBR(surface, screenPosition, viewPosition, lightingData);
    
    CalculateLighting_BasePBR(surface, screenPosition, lightingData);

    // // Apply Direct Lighting
    // ApplyDirectLighting(surface, lightingData, screenPosition);
    // 
    // // Apply Image Based Lighting (IBL)
    // ApplyIblForward(surface, lightingData);
    // 
    // // Finalize Lighting
    // lightingData.FinalizeLighting(surface);
    // 
    // //lightingData.specularLighting *= lightingData.specularOcclusion;
    // //lightingData.diffuseLighting *= lightingData.diffuseAmbientOcclusion;

#if 0

    bool specularIsNan = isnan(lightingData.specularLighting.x) ||
                         isnan(lightingData.specularLighting.y) ||
                         isnan(lightingData.specularLighting.z);

    bool specularIsNeg = lightingData.specularLighting.x < 0.0f ||
                         lightingData.specularLighting.y < 0.0f ||
                         lightingData.specularLighting.z < 0.0f;

    bool diffuseIsNan = isnan(lightingData.diffuseLighting.x) ||
                        isnan(lightingData.diffuseLighting.y) ||
                        isnan(lightingData.diffuseLighting.z);

    bool diffuseIsNeg = lightingData.diffuseLighting.x < 0.0f ||
                        lightingData.diffuseLighting.y < 0.0f ||
                        lightingData.diffuseLighting.z < 0.0f;

    if(diffuseIsNan)
    {
        lightingData.specularLighting = redColor;
    }
    else if(diffuseIsNeg)
    {
        lightingData.specularLighting = blueColor;
    }
    else
    {
        lightingData.specularLighting = greenColor;
    }

    //ApplySimpleSpotLights(surface, lightingData);

    //if(ViewSrg::m_simpleSpotLightCount >= 2)
    if(false)
    {
        //lightingData.diffuseLighting = lerp(redColor, lightingData.diffuseLighting, 0.5f);

        for(uint lightIndex = 0; lightIndex < ViewSrg::m_simpleSpotLightCount; lightIndex++)
        {
            ViewSrg::SimpleSpotLight light = ViewSrg::m_simpleSpotLights[lightIndex];
            ApplySimpleSpotLight(light, surface, lightingData);

            /*
            real3 posToLight = real3(light.m_position - surface.position);
    
            real3 dirToLight = normalize(posToLight);
            real dotWithDirection = dot(dirToLight, -real3(light.m_direction));

            // If outside the outer cone angle return.
            if (dotWithDirection < real(light.m_cosOuterConeAngle))
            {
                lightingData.diffuseLighting = lerp(blueColor, lightingData.diffuseLighting, 0.5f);
            }
            else
            {

                real d2 = dot(posToLight, posToLight); // light distance squared
                real falloff = d2 * real(light.m_invAttenuationRadiusSquared);
                real cosInnerConeAngle = real(light.m_cosInnerConeAngle);

                // Only calculate shading if light is in range
                if (falloff < 1.0)
                {
                    //lightingData.diffuseLighting = lerp(blueColor, lightingData.diffuseLighting, 0.5f);

                    // Smoothly adjusts the light intensity so it reaches 0 at light.m_attenuationRadius distance
                    real radiusAttenuation = 1.0 - (falloff * falloff);
                    radiusAttenuation = radiusAttenuation * radiusAttenuation;
        
                    // Standard quadratic falloff
                    d2 = max(0.001 * 0.001, d2); // clamp the light to at least 1mm away to avoid extreme values.
                    real3 lightIntensity = (real3(light.m_rgbIntensityCandelas) / d2) * radiusAttenuation;
                    real3 posToLightDir = normalize(posToLight);

                    if (dotWithDirection < cosInnerConeAngle) // in penumbra
                    {   
                        // Normalize into 0.0 - 1.0 space.
                        real penumbraMask = (dotWithDirection - real(light.m_cosOuterConeAngle)) / (cosInnerConeAngle - real(light.m_cosOuterConeAngle));
            
                        // Apply smoothstep
                        penumbraMask = penumbraMask * penumbraMask * (3.0 - 2.0 * penumbraMask);
            
                        lightIntensity *= penumbraMask;
                    }

                    real3 diffuseL = GetDiffuseLighting(surface, lightingData, lightIntensity, posToLightDir);
                    real3 specularL = GetSpecularLighting(surface, lightingData, lightIntensity, posToLightDir);
                    
                    if( (diffuseL.r + diffuseL.g + diffuseL.b) > 0.0f)
                    {
                        //lightingData.diffuseLighting = lerp(greenColor, lightingData.diffuseLighting, 0.5f);
                    }
                    
                    // Diffuse contribution
                    lightingData.diffuseLighting += diffuseL;
                    
                    // Specular contribution
                    lightingData.specularLighting += specularL;

                }
            }
            */
        }
    }
    //else
    //{
    //    lightingData.diffuseLighting = lerp(blueColor, lightingData.diffuseLighting, 0.5f);
    //}

    //lightingData.diffuseLighting = lerp(redColor, lightingData.diffuseLighting, lightingData.diffuseAmbientOcclusion);
    //lightingData.specularLighting = lerp(blueColor, lightingData.specularLighting, lightingData.specularOcclusion);

    //lightingData.diffuseLighting = saturate(surface.normal * 0.5f + 0.5f);
    //lightingData.diffuseLighting = saturate(surface.albedo);
    //lightingData.diffuseLighting = saturate(surface.roughnessLinear * surface.specularF0 * 6.0f);
    //lightingData.diffuseLighting = real3(0.2, 0.2, 0.0);
    //lightingData.specularLighting = real3(0.0, 0.0, 0.0);

#endif

    return lightingData;
}
