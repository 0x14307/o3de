/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

// This #define magic lets you use the EvaluateSurface function in this file without making it the final EvaluateSurface
// used in your shader. Simply #define EvaluateSurface to your custom definition before including this file
//
#ifndef EvaluateSurface
#define EvaluateSurface(geoData)        EvaluateSurface_NewPBR(geoData)
#endif

#include "../BasePBR/BasePBR_Surface.azsli"

Surface EvaluateSurface_NewPBR(
    float3 positionWS,
    float3 vertexNormal,
    float3 tangents[UvSetCount],
    float3 bitangents[UvSetCount],
    float2 uv[UvSetCount],
    bool isFrontFace)
{
    Surface surface = EvaluateSurface_BasePBR(positionWS, vertexNormal, tangents, bitangents, uv, isFrontFace);

    // ------- Emissive -------

    float2 emissiveUv = uv[MaterialSrg::m_emissiveMapUvIndex];
    surface.emissiveLighting = GetEmissiveInput(MaterialSrg::m_emissiveMap, MaterialSrg::m_sampler, emissiveUv, MaterialSrg::m_emissiveIntensity, MaterialSrg::m_emissiveColor.rgb, o_emissiveEnabled, o_emissive_useTexture);

    // ------- Occlusion -------
    
    surface.diffuseAmbientOcclusion = GetOcclusionInput(MaterialSrg::m_diffuseOcclusionMap, MaterialSrg::m_sampler, uv[MaterialSrg::m_diffuseOcclusionMapUvIndex], MaterialSrg::m_diffuseOcclusionFactor, o_diffuseOcclusion_useTexture);
    surface.specularOcclusion = GetOcclusionInput(MaterialSrg::m_specularOcclusionMap, MaterialSrg::m_sampler, uv[MaterialSrg::m_specularOcclusionMapUvIndex], MaterialSrg::m_specularOcclusionFactor, o_specularOcclusion_useTexture);

    return surface;
}

Surface EvaluateSurface_NewPBR(PixelGeometryData geoData)
{
    return EvaluateSurface_NewPBR(
        geoData.positionWS,
        geoData.vertexNormal,
        geoData.tangents,
        geoData.bitangents,
        geoData.uv,
        geoData.isFrontFace);
}
