/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

// ------------------------------------------------------------------------------
// NOTE: The following must be included or defined before including this file:
//       - Surface          - LightingData
// ---------------------------------------------------------------------------------

#include <Atom/Features/PBR/LightingOptions.azsli>

// Analytical integation (approximation) of diffusion profile over radius, could be replaced by other pre integrated kernels
// such as sum of Gaussian (see T(s))
float3 TransmissionKernel(float t, float3 s)
{
    float3 exponent = s * t;
    return 0.25 * (1.0 / exp(exponent) + 3.0 / exp(exponent / 3.0));
}

// Analytical integation (approximation) of diffusion profile over radius, could be precomputed in a LUT
float3 T(float s) 
{
    // dipoles and multipoles are approximated with sums of a small number of Gaussians with variable weights and variances
    return float3(0.233, 0.455, 0.649) * exp(-s*s/0.0064) +
    float3(0.1, 0.336, 0.344) * exp(-s*s/0.0484) +
    float3(0.118, 0.198, 0.0) * exp(-s*s/0.187) +
    float3(0.113, 0.007, 0.007) * exp(-s*s/0.567) +
    float3(0.358, 0.004, 0.0) * exp(-s*s/1.99) +
    float3(0.078, 0.0, 0.0) * exp(-s*s/7.41);
}

float3 GetBackLighting(Surface surface, LightingData lightingData, float3 lightIntensity, float3 dirToLight, float transmissionDistance)
{
    float3 result = float3(0.0, 0.0, 0.0);
    float thickness = 0.0; 
    float4 transmissionParams = surface.transmission.transmissionParams;

    switch(o_transmission_mode)
    {
        case TransmissionMode::None:
            break;

        case TransmissionMode::ThickObject: 
            // Thick object mode, using back lighting approximation proposed by Brisebois B. C. and Bouchard M. 2011
            // https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/

            {
                thickness = max(transmissionDistance, surface.transmission.thickness);
                float transmittance = pow( saturate( dot( lightingData.dirToCamera, -normalize( dirToLight + surface.normal * transmissionParams.z ) ) ), transmissionParams.y ) * transmissionParams.w;
                float lamberAttenuation = exp(-thickness * transmissionParams.x) * saturate(1.0 - thickness);
                result = transmittance * lamberAttenuation * lightIntensity;
            }
            break;

        case TransmissionMode::ThinObject:
            // Thin object mode, based on Jimenez J. et al, 2010, "Real-Time Realistic Skin Translucency"
            // http://www.iryoku.com/translucency/downloads/Real-Time-Realistic-Skin-Translucency.pdf
            
            {
                // Irradiance arround surface point. 
                // Begin the transmittance dot product slightly before it would with the regular dot(N,L)
                float E = max(0.30 + dot(-surface.normal, dirToLight), 0.0);

                // Transmission distance computed from shadowmaps modulated by editor-exposed parameters
                float s = transmissionDistance * surface.transmission.thickness * (20 - transmissionParams.w) * 10;
                
                // Albedo at front (surface point) is used to approximate irradiance at the back of the object
                // See observation 4 in [Jimenez J. et al, 2010] 
                result = T(s) * lightIntensity * surface.albedo * E;
            }
            break;
    }
    
    return result;
}

