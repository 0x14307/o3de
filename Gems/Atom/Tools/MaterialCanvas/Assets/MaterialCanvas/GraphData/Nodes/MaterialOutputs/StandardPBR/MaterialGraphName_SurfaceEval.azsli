/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

// This #define magic lets you use the EvaluateSurface function in this file without making it the final EvaluateSurface
// used in your shader. Simply #define EvaluateSurface to your custom definition before including this file
//
#ifndef EvaluateSurface
#define EvaluateSurface(geoData)        EvaluateSurface_StandardPBR(geoData)
#endif

#include <Atom/Features/PBR/LightingOptions.azsli>
#include <Atom/Features/MatrixUtility.azsli>

Surface EvaluateSurface_StandardPBR(
    float3 positionWS,
    float3 vertexNormal,
    float3 tangents[UvSetCount],
    float3 bitangents[UvSetCount],
    float2 uvs[UvSetCount],
    bool isFrontFace,
    bool isDisplacementClipped)
{
    #define O3DE_MC_POSITION positionWS
    #define O3DE_MC_UV(index) uvs[clamp(index, 0, UvSetCount-1];
    #define O3DE_MC_NORMAL vertexNormal
    #define O3DE_MC_TANGENT tangent[0]
    #define O3DE_MC_BITANGENT bitangent[0]
    #define O3DE_MC_WORLD_POSITION positionWS

    // O3DE_GENERATED_INSTRUCTIONS_BEGIN: inNormal, inBaseColor, inMetallic, inRoughness, inSpecularF0Factor, inEmissive, inAlpha
    float3 inNormal = vertexNormal;
    float3 inBaseColor = {1.0, 1.0, 1.0};
    float3 inEmissive = {0.0, 0.0, 0.0};
    float inMetallic = 0.0;
    float inRoughness = 0.0;
    float inSpecularF0Factor = 0.0;
    float inAlpha = 1.0;
    // O3DE_GENERATED_INSTRUCTIONS_END

    float inDiffuseAmbientOcclusion = 0.0;
    float inSpecularOcclusion = 0.0;
    bool inOpacityAffectsSpecularFactor = true;

    #undef O3DE_MC_POSITION
    #undef O3DE_MC_UV
    #undef O3DE_MC_NORMAL
    #undef O3DE_MC_TANGENT
    #undef O3DE_MC_BITANGENT
    #undef O3DE_MC_WORLD_POSITION

    Surface surface;
    surface.position = positionWS;
    surface.vertexNormal = vertexNormal;
    surface.normal = (float3)inNormal;
    surface.roughnessLinear = inRoughness;
    surface.SetAlbedoAndSpecularF0(inBaseColor, inSpecularF0Factor, inMetallic);
    surface.CalculateRoughnessA();


    // ------- Parallax Clipping -------

#if 0
    if(o_parallax_highlightClipping && isDisplacementClipped)
    {
        ApplyParallaxClippingHighlight(surface.albedo);
    }
#endif

    CheckClipping(inAlpha, 0.99);
    surface.alpha = inAlpha;
    surface.emissiveLighting = inEmissive;
    surface.diffuseAmbientOcclusion = inDiffuseAmbientOcclusion;
    surface.specularOcclusion = inSpecularOcclusion;
    surface.opacityAffectsSpecularFactor = inOpacityAffectsSpecularFactor;

    // ------- Clearcoat -------

#if ENABLE_CLEAR_COAT
    // Todo: Clean up the double uses of these clear coat flags
    //if(o_clearCoat_feature_enabled)
    {
        //if(o_clearCoat_enabled)
        {
            surface.clearCoat.factor = 0.0;
            surface.clearCoat.roughness = 0.0;
            surface.clearCoat.normal = vertexNormal;
        }

        ApplyClearCoatToSpecularF0(surface.specularF0, surface.clearCoat.factor);
    }
#endif

    return surface;
}

Surface EvaluateSurface_StandardPBR(PixelGeometryData geoData)
{
    return EvaluateSurface_StandardPBR(
        geoData.positionWS,
        geoData.vertexNormal,
        geoData.tangents,
        geoData.bitangents,
        geoData.uvs,
        geoData.isFrontFace,
        geoData.isDisplacementClipped);
}
