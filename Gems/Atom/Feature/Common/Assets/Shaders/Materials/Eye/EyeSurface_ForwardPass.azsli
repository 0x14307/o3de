/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#include <Atom/Features/Pipeline/Forward/ForwardPassSrg.azsli>

// Pass Output
#include <Atom/Features/Pipeline/Forward/ForwardSubsurfacePassOutput.azsli>

// Utility
#include <Atom/Features/ColorManagement/TransformColor.azsli>

// Custom Surface & Lighting
#include <Atom/Features/PBR/Lighting/EyeLighting.azsli>

// Decals
#include <Atom/Features/PBR/Decals.azsli>



// ---------- Pixel Shader ----------

PbrLightingOutput EyePS_Common(VSOutput IN)
{

    Surface surface;
    surface.position = IN.m_worldPosition;

    EvaluateEyeSurface(IN.m_normal, IN.m_localPosition, IN.m_uv, tangents, bitangents, isFrontFace, surface);

    // ------- Lighting Data -------

    LightingData lightingData;

    // Light iterator
    lightingData.tileIterator.Init(IN.m_position, PassSrg::m_lightListRemapped, PassSrg::m_tileLightData);
    lightingData.Init(surface.position, surface.normal, surface.roughnessLinear);
    
    // Diffuse and Specular response (used in IBL calculations)
    lightingData.specularResponse = FresnelSchlickWithRoughness(lightingData.NdotV, surface.specularF0, surface.roughnessLinear);
    lightingData.diffuseResponse = 1.0 - lightingData.specularResponse;

    // ------- Lighting Calculation -------


    // Apply Direct Lighting
    ApplyDirectLighting(surface, lightingData, IN.m_position);

    // Apply Image Based Lighting (IBL)
    ApplyIBL(surface, lightingData);

    // Finalize Lighting
    lightingData.FinalizeLighting(surface.transmission.tint);

    PbrLightingOutput lightingOutput = GetPbrLightingOutput(surface, lightingData);
        
    // ------- Preparing output -------

    // Pack factor and quality, drawback: because of precision limit of float16 cannot represent exact 1, maximum representable value is 0.9961
    uint factorAndQuality = dot(round(float2(saturate(surface.subsurfaceScatteringFactor), MaterialSrg::m_subsurfaceScatteringQuality) * 255), float2(256, 1));
    lightingOutput.m_diffuseColor.w = factorAndQuality * (o_enableSubsurfaceScattering ? 1.0 : -1.0);
    lightingOutput.m_scatterDistance = MaterialSrg::m_scatterDistance;

    return lightingOutput;
}

[earlydepthstencil]
ForwardPassOutput EyePS(VSOutput IN)
{
    ForwardPassOutput OUT;

    PbrLightingOutput lightingOutput = EyePS_Common(IN);

    OUT.m_diffuseColor = lightingOutput.m_diffuseColor;
    OUT.m_specularColor = lightingOutput.m_specularColor;
    OUT.m_specularF0 = lightingOutput.m_specularF0;
    OUT.m_albedo = lightingOutput.m_albedo;
    OUT.m_normal = lightingOutput.m_normal;
    OUT.m_scatterDistance = lightingOutput.m_scatterDistance;

    return OUT;
}
