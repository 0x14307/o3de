/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */



#include <Atom/Features/SrgSemantics.azsli>

#include <Atom/Features/PostProcessing/FullscreenPixelInfo.azsli>
#include <Atom/Features/PostProcessing/FullscreenVertex.azsli>
#include <Atom/Features/PostProcessing/PostProcessUtil.azsli>
#include <Atom/Features/ScreenSpace/ScreenSpaceUtil.azsli>
#include <Atom/Features/Shadow/NormalOffsetShadows.azsli>
#include <Atom/Features/Shadow/BicubicPcfFilters.azsli>
#include <Atom/Features/Shadow/Shadow.azsli>
#include <Atom/RPI/Math.azsli>
#include <viewsrg.srgi>
#include <scenesrg.srgi>

enum ShadowFilterMethod
{
    ShadowFilterMethod_None = 0,
    ShadowFilterMethod_Pcf = 1,
    ShadowFilterMethod_Esm = 2,
    ShadowFilterMethod_EsmPcf = 3
};

static const float CascadeBlendArea = 0.015f; // might be worth exposing this as a slider.

ShaderResourceGroup PassSrg : SRG_PerPass
{
    Sampler PointSampler
    {
        MinFilter = Point;
        MagFilter = Point;
        MipFilter = Point;
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
    };
    
    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
    };

    struct Constants
    {
        float2 m_screenSize;
        int m_lightIndex;
        int m_filterMode;
        int m_blendBetweenCascadesEnable;        
        int m_receiverShadowPlaneBiasEnable;
        int m_msaaCount;
        float m_invMsaaCount;
    };    
    
    Constants m_constantData;
    Texture2DArray<float> m_directionalLightShadowmap;   
    Texture2DArray<float> m_directionalLightExponentialShadowmap;    
    Texture2DMS<float> m_depth;
}

#include <Atom/RPI/ShaderResourceGroups/DefaultDrawSrg.azsli>


class DirectionalLightShadowCalculator
{
    struct DebugInfo
    {
        uint m_cascadeIndex; // cascade index where lit ratio determined.
        bool m_usePcfFallback;
    };

    void SetBlendBetweenCascadesEnable(const bool enable)
    {
        m_blendBetweenCascadesEnable = enable;
    }
    
    void SetShadowmaps(Texture2DArray<float> dirShadowMap, Texture2DArray<float> expShadowmap)
    {
        m_directionalLightShadowmap = dirShadowMap;   
        m_directionalLightExponentialShadowmap = expShadowmap;        
    }

    void SetReceiverShadowPlaneBiasEnable(const bool enable)
    {
        m_receiverShadowPlaneBiasEnable = enable;
    }

    void SetWorldNormal(const float3 n)
    {
        m_worldNormal = n;
    }
    
    void SetLightIndex(const int lightIndex)
    {
        m_lightIndex = lightIndex;    
    }
    
    void SetFilterMode(const int filterMode)
    {
        m_filterMode = filterMode;
    }

    // This outputs the coordinate in shadowmap Texture space of the given point.
    void ComputeShadowCoords(
        const float3 worldPosition,
        const float3 worldNormal)
    {
        const float shadowBias = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowBias;

        const float4x4 lightViewToShadowmapMatrices[ViewSrg::MaxCascadeCount] = ViewSrg::m_directionalLightShadows[m_lightIndex].m_lightViewToShadowmapMatrices;
        const float4x4 worldToLightViewMatrices[ViewSrg::MaxCascadeCount] = ViewSrg::m_directionalLightShadows[m_lightIndex].m_worldToLightViewMatrices;

        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        const float3 shadowOffset = ComputeNormalShadowOffset(ViewSrg::m_directionalLightShadows[m_lightIndex].m_normalShadowBias, worldNormal, ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize);

        for (uint index = 0; index < cascadeCount; ++index)
        {        
            float4 lightSpacePos = mul(worldToLightViewMatrices[index], float4(worldPosition + shadowOffset, 1.));
            lightSpacePos.z += shadowBias;
            
            const float4 clipSpacePos = mul(lightViewToShadowmapMatrices[index], lightSpacePos);                
            m_shadowCoords[index] = clipSpacePos.xyz / clipSpacePos.w;
        }
                
        if (m_receiverShadowPlaneBiasEnable)
        {
            [unroll]
            for(int i = 0 ; i < ViewSrg::MaxCascadeCount ; ++i)
            {
                m_shadowPosDX[i] = ddx_fine(m_shadowCoords[i]);
                m_shadowPosDY[i] = ddy_fine(m_shadowCoords[i]);        
            }    
        }        
    }

    bool2 IsShadowed(const float3 shadowCoord, const uint indexOfCascade)
    {
        static const float PixelMargin = 1.5; // avoiding artifact between cascade levels.
        static const float DepthMargin = 1e-8; // avoiding artifact when near depth bounds.

        // size is the shadowap's width and height.
        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;

        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;

        [branch]
        if (shadowCoord.x >= 0. && shadowCoord.x * size < size - PixelMargin &&
            shadowCoord.y >= 0. && shadowCoord.y * size < size - PixelMargin)
        {
            const float3 coord = float3(shadowCoord.xy, indexOfCascade);
            const float depthInShadowmap = m_directionalLightShadowmap.Sample(PassSrg::LinearSampler, coord).r;
            // Test the case where the shadowed pixel is nearer than the maximal depth
            // of the cascade.  Otherwise, escalate the next cascade.
            if (shadowCoord.z < 1. - DepthMargin)
            {
                const float depthDiff = shadowCoord.z - depthInShadowmap;
                return bool2(true, (depthDiff > m_slopeBias[indexOfCascade]));
            }
        }
        return bool2(false, false);
    }
    
    float GetVisibility()
    {   
        // Calculate slope bias
        const float3 lightDirection = normalize(SceneSrg::m_directionalLights[m_lightIndex].m_direction);
        const float cosTheta = -dot(m_worldNormal, lightDirection);
        const float sinTheta = sqrt(1 - cosTheta * cosTheta);
        const float tanTheta = sinTheta / cosTheta;
        for (uint cascadeIndex = 0; cascadeIndex < ViewSrg::MaxCascadeCount; ++cascadeIndex)
        {
            const float slopeBiasBase = ViewSrg::m_directionalLightShadows[m_lightIndex].m_slopeBiasBase[cascadeIndex];
            m_slopeBias[cascadeIndex] = slopeBiasBase * tanTheta;
        }
    
        float lit = 1;
        switch(m_filterMode)
        {
            case ShadowFilterMethod_None:
                lit = GetVisibilityFromLightNoFilter();
                break;
            case ShadowFilterMethod_Pcf:
                lit = GetVisibilityFromLightPcf();
                break;
            case ShadowFilterMethod_Esm:
                lit = GetVisibilityFromLightEsm();
                break;
            case ShadowFilterMethod_EsmPcf:
                lit = GetVisibilityFromLightEsmPcf();
                break;
        }
                    
        return lit;
    }
    
    float GetVisibilityFromLightNoFilter()
    {       
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        for (uint indexOfCascade = 0; indexOfCascade < cascadeCount; ++indexOfCascade)
        {
            const bool2 checkedShadowed = IsShadowed(
                m_shadowCoords[indexOfCascade],
                indexOfCascade);
            if (checkedShadowed.x)
            {
                m_debugInfo.m_cascadeIndex = indexOfCascade;
                return checkedShadowed.y ? 0. : 1.;
            }
        }
        m_debugInfo.m_cascadeIndex = cascadeCount;
        return 1.;
    }    

    float SamplePcfBicubic(const float3 shadowCoord, const uint indexOfCascade)
    {
        const uint filteringSampleCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_filteringSampleCount;
        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;
        
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;

        SampleShadowMapBicubicParameters param;
        param.shadowMap = m_directionalLightShadowmap;
        param.shadowPos = float3(shadowCoord.xy, indexOfCascade);
        param.shadowMapSize = size;
        param.invShadowMapSize = rcp(size); 
        param.comparisonValue = shadowCoord.z;
        param.samplerState = SceneSrg::m_hwPcfSampler;
        param.receiverPlaneDepthBias = PassSrg::m_constantData.m_receiverShadowPlaneBiasEnable ? ComputeReceiverPlaneDepthBias(m_shadowPosDX[indexOfCascade], m_shadowPosDY[indexOfCascade]) : 0;
        
        [branch]     
        if (filteringSampleCount <= 4)       
        {
            return SampleShadowMapBicubic_4Tap(param);
        }
        else if (filteringSampleCount <= 9)
        {
            return SampleShadowMapBicubic_9Tap(param);
        }
        else
        {
            return SampleShadowMapBicubic_16Tap(param);
        }
    }
     
    float GetVisibilityFromLightPcf()
    {   
        static const float PixelMargin = 1.5; // avoiding artifact between cascade levels.
        static const float DepthMargin = 1e-8; // avoiding artifact when near depth bounds.

        bool cascadeFound = false;
        int currentCascadeIndex = 0;

        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        for (uint indexOfCascade = 0; indexOfCascade < cascadeCount; ++indexOfCascade)
        {
            const float3 shadowCoord = m_shadowCoords[indexOfCascade];
            
            if (shadowCoord.x >= 0. && shadowCoord.x * size < size - PixelMargin &&
                shadowCoord.y >= 0. && shadowCoord.y * size < size - PixelMargin && 
                shadowCoord.z < 1. - DepthMargin)
            {
                currentCascadeIndex = m_debugInfo.m_cascadeIndex = indexOfCascade;
                cascadeFound = true;
                break;
            }
        }

        [branch]
        if (cascadeFound)
        {
            float lit = SamplePcfBicubic(m_shadowCoords[currentCascadeIndex], currentCascadeIndex);
            
            if(m_blendBetweenCascadesEnable) 
            {  
                const float blendBetweenCascadesAmount = CalculateCascadeBlendAmount(m_shadowCoords[currentCascadeIndex].xyz);

                const int nextCascadeIndex = currentCascadeIndex + 1;
                [branch]
                if (blendBetweenCascadesAmount < 1.0f && nextCascadeIndex < cascadeCount)
                {
                    const float nextLit = SamplePcfBicubic(m_shadowCoords[nextCascadeIndex], nextCascadeIndex);
                    lit = lerp(nextLit, lit, blendBetweenCascadesAmount);             
                }
            } 

            return lit;
        }

        m_debugInfo.m_cascadeIndex = cascadeCount;
        return 1.;
    } 
            
    float GetVisibilityFromLightEsm()
    {
        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;

        for (uint indexOfCascade = 0; indexOfCascade < cascadeCount; ++indexOfCascade)
        {
            const float3 shadowCoord = m_shadowCoords[indexOfCascade];
            const float distanceMin = ViewSrg::m_esmsDirectional[indexOfCascade].m_lightDistanceOfCameraViewFrustum;
            bool2 checkedShadowed = IsShadowed(shadowCoord, indexOfCascade);
            const float depthDiff = shadowCoord.z - distanceMin;
        
            [branch]
            if (checkedShadowed.x && depthDiff >= 0)
            {
                const float distanceWithinCameraView = depthDiff / (1. - distanceMin);
                const float3 coord = float3(shadowCoord.xy, indexOfCascade);
                const float occluder = m_directionalLightExponentialShadowmap.Sample(PassSrg::LinearSampler, coord).r;                        
                const float exponent = -EsmExponentialShift * (distanceWithinCameraView - occluder);
                const float ratio = exp(exponent);

                m_debugInfo.m_cascadeIndex = indexOfCascade;
                return saturate(ratio);
            }
        }

        m_debugInfo.m_cascadeIndex = cascadeCount;
        return 1.;
    }
    
    float GetVisibilityFromLightEsmPcf()
    {
        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;

        for (uint indexOfCascade = 0; indexOfCascade < cascadeCount; ++indexOfCascade)
        {
            const float3 shadowCoord = m_shadowCoords[indexOfCascade];
            const float distanceMin = ViewSrg::m_esmsDirectional[indexOfCascade].m_lightDistanceOfCameraViewFrustum;
            bool2 checkedShadowed = IsShadowed(shadowCoord, indexOfCascade);
            const float depthDiff = shadowCoord.z - distanceMin;
        
            [branch]
            if (checkedShadowed.x && depthDiff >= 0)
            {
                const float distanceWithinCameraView = depthDiff / (1. - distanceMin);
                const float3 coord = float3(shadowCoord.xy, indexOfCascade);
                const float occluder = m_directionalLightExponentialShadowmap.Sample(PassSrg::LinearSampler, coord).r;
                const float exponent = -EsmExponentialShift * (distanceWithinCameraView - occluder);
                float ratio = exp(exponent);

                static const float pcfFallbackThreshold = 1.04;
                if (ratio > pcfFallbackThreshold)
                {
                    m_debugInfo.m_usePcfFallback = true;
                    ratio = GetVisibilityFromLightPcf();
                }
                else
                {
                    m_debugInfo.m_usePcfFallback = false;
                }
                m_debugInfo.m_cascadeIndex = indexOfCascade;
                return saturate(ratio);
            }
        }

        m_debugInfo.m_usePcfFallback = false;
        m_debugInfo.m_cascadeIndex = cascadeCount;
        return 1.;
    }

    float CalculateCascadeBlendAmount(const float3 texCoord)
    {
        const float distanceToOneMin = min3(1.0f - texCoord);
        const float currentPixelsBlendBandLocation = min(min(texCoord.x, texCoord.y), distanceToOneMin);
        return currentPixelsBlendBandLocation / CascadeBlendArea;
    }
    
    float3 m_shadowCoords[ViewSrg::MaxCascadeCount];
    float m_slopeBias[ViewSrg::MaxCascadeCount];
    float3 m_shadowPosDX[ViewSrg::MaxCascadeCount];
    float3 m_shadowPosDY[ViewSrg::MaxCascadeCount];
    float3 m_worldNormal;
    bool m_receiverShadowPlaneBiasEnable;
    bool m_blendBetweenCascadesEnable;
    int m_lightIndex;
    int m_filterMode;
    Texture2DArray<float> m_directionalLightShadowmap;   
    Texture2DArray<float> m_directionalLightExponentialShadowmap;        
    DebugInfo m_debugInfo;    
};

float3 ComputeWorldNormal(VSOutput IN)
{
    const float offset = 1;
    const float2 invScreenSize = rcp(PassSrg::m_constantData.m_screenSize);

    const int2 texCoord = IN.m_position;

    const float2 uv0 = IN.m_texCoord; // center
    const float2 uv1 = IN.m_texCoord + float2(offset, 0) * invScreenSize; // right 
    const float2 uv2 = IN.m_texCoord + float2(0, offset) * invScreenSize; // top

    const int sampleIndex = 0;
    const float depth0 = PassSrg::m_depth.Load(texCoord, sampleIndex);
    const float depth1 = PassSrg::m_depth.Load(texCoord + int2(1,0), sampleIndex);
    const float depth2 = PassSrg::m_depth.Load(texCoord + int2(0,1), sampleIndex);

    const float3 P0 = WorldPositionFromDepthBuffer(uv0, depth0).xyz;
    const float3 P1 = WorldPositionFromDepthBuffer(uv1, depth1).xyz;
    const float3 P2 = WorldPositionFromDepthBuffer(uv2, depth2).xyz;
    
    return normalize(cross(P2 - P0, P1 - P0));   
}

PSOutput MainPS(VSOutput IN)
{
    const float3 worldNormal = ComputeWorldNormal(IN);    

    DirectionalLightShadowCalculator directionalLightShadow;
    directionalLightShadow.SetLightIndex(PassSrg::m_constantData.m_lightIndex);
    directionalLightShadow.SetWorldNormal(worldNormal);
    directionalLightShadow.SetReceiverShadowPlaneBiasEnable(PassSrg::m_constantData.m_receiverShadowPlaneBiasEnable);
    directionalLightShadow.SetFilterMode(PassSrg::m_constantData.m_filterMode);
    directionalLightShadow.SetBlendBetweenCascadesEnable(PassSrg::m_constantData.m_blendBetweenCascadesEnable);
    directionalLightShadow.SetShadowmaps(PassSrg::m_directionalLightShadowmap, PassSrg::m_directionalLightExponentialShadowmap);
        
    float sumDepth = 0;
    for(int sampleIndex = 0 ; sampleIndex < PassSrg::m_constantData.m_msaaCount ; ++sampleIndex)
    {
        sumDepth += PassSrg::m_depth.Load(IN.m_position.xy, sampleIndex);
    }
    const float zDepth = sumDepth * PassSrg::m_constantData.m_invMsaaCount;
    
    const float3 surfacePosWS = WorldPositionFromDepthBuffer(IN.m_texCoord, zDepth).xyz;     
    const float3 surfacePosVS = ViewPositionFromDepthBuffer(IN.m_texCoord, zDepth).xyz;     

    directionalLightShadow.ComputeShadowCoords(surfacePosWS, worldNormal);
   
    PSOutput OUT;   
    float vis = directionalLightShadow.GetVisibility();
    
    OUT.m_color = vis;
   
    return OUT; 
}


