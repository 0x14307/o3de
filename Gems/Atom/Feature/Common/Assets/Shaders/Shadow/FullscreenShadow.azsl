/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */



#include <Atom/Features/SrgSemantics.azsli>

#include <Atom/Features/PostProcessing/FullscreenPixelInfo.azsli>
#include <Atom/Features/PostProcessing/FullscreenVertex.azsli>
#include <Atom/Features/PostProcessing/PostProcessUtil.azsli>
#include <Atom/Features/ScreenSpace/ScreenSpaceUtil.azsli>
#include <Atom/Features/Shadow/NormalOffsetShadows.azsli>
#include <Atom/Features/Shadow/BicubicPcfFilters.azsli>
#include <Atom/Features/Shadow/Shadow.azsli>
#include <Atom/RPI/Math.azsli>
#include <viewsrg.srgi>
#include <scenesrg.srgi>


ShaderResourceGroup PassSrg : SRG_PerPass
{
    Sampler PointSampler
    {
        MinFilter = Point;
        MagFilter = Point;
        MipFilter = Point;
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
    };
    
    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
    };

    struct Constants
    {
        float2 m_screenSize;
        int m_lightIndex;
        int m_filterMode;
        int m_blendBetweenCascadesEnable;        
        int m_receiverShadowPlaneBiasEnable;
        int m_msaaCount;
        float m_invMsaaCount;
    };    
    
    Constants m_constantData;
    Texture2DArray<float> m_directionalLightShadowmap;   
    Texture2DArray<float> m_directionalLightExponentialShadowmap;    
    Texture2DMS<float> m_depth;
}

#include <Atom/RPI/ShaderResourceGroups/DefaultDrawSrg.azsli>
#include <Atom/Features/Shadow/DirectionalLightShadowCalculator.azsli>

float3 ComputeWorldNormal(VSOutput IN)
{
    const float offset = 1;
    const float2 invScreenSize = rcp(PassSrg::m_constantData.m_screenSize);

    const int2 texCoord = IN.m_position;

    const float2 uv0 = IN.m_texCoord; // center
    const float2 uv1 = IN.m_texCoord + float2(offset, 0) * invScreenSize; // right 
    const float2 uv2 = IN.m_texCoord + float2(0, offset) * invScreenSize; // top

    const int sampleIndex = 0;
    const float depth0 = PassSrg::m_depth.Load(texCoord, sampleIndex);
    const float depth1 = PassSrg::m_depth.Load(texCoord + int2(1,0), sampleIndex);
    const float depth2 = PassSrg::m_depth.Load(texCoord + int2(0,1), sampleIndex);

    const float3 P0 = WorldPositionFromDepthBuffer(uv0, depth0).xyz;
    const float3 P1 = WorldPositionFromDepthBuffer(uv1, depth1).xyz;
    const float3 P2 = WorldPositionFromDepthBuffer(uv2, depth2).xyz;
    
    return normalize(cross(P2 - P0, P1 - P0));   
}

PSOutput MainPS(VSOutput IN)
{
    const float3 worldNormal = ComputeWorldNormal(IN);    

    const int sampleIndex = 0; // Note precision is much better is the multisample position is dead center.
    const float zDepth = PassSrg::m_depth.Load(IN.m_position.xy, sampleIndex);
    
    const float3 surfacePosWS = WorldPositionFromDepthBuffer(IN.m_texCoord, zDepth).xyz;     
   
    PSOutput OUT;   

    DirectionalShadowCalculator calc;
    calc.SetLightIndex(PassSrg::m_constantData.m_lightIndex);
    calc.SetWorldNormal(worldNormal);
    calc.SetReceiverShadowPlaneBiasEnable(PassSrg::m_constantData.m_receiverShadowPlaneBiasEnable);
    calc.SetFilterMode((ShadowFilterMethod)PassSrg::m_constantData.m_filterMode);
    calc.SetBlendBetweenCascadesEnable(PassSrg::m_constantData.m_blendBetweenCascadesEnable);
    calc.SetShadowmaps(PassSrg::m_directionalLightShadowmap, PassSrg::m_directionalLightExponentialShadowmap);
    calc.SetWorldPos(surfacePosWS);

    float vis = calc.GetVisibility();
    
    OUT.m_color = vis;
   
    return OUT; 
}


