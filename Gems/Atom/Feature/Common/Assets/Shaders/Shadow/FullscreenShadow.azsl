/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */



#include <Atom/Features/SrgSemantics.azsli>

#include <Atom/Features/PostProcessing/FullscreenPixelInfo.azsli>
#include <Atom/Features/PostProcessing/FullscreenVertex.azsli>
#include <Atom/Features/PostProcessing/PostProcessUtil.azsli>
#include <Atom/Features/ScreenSpace/ScreenSpaceUtil.azsli>
#include <Atom/Features/Shadow/NormalOffsetShadows.azsli>
#include <Atom/Features/Shadow/BicubicPcfFilters.azsli>
#include <Atom/Features/Shadow/Shadow.azsli>
#include <viewsrg.srgi>


ShaderResourceGroup PassSrg : SRG_PerPass
{
    Sampler LinearSampler
    {
        MinFilter = Linear;
        MagFilter = Linear;
        MipFilter = Linear;
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
    };

    // Hardware PCF comparison sampler that is used when sampling the shadow maps
    SamplerComparisonState m_hwPcfSampler
    {
        AddressU = Clamp;
        AddressV = Clamp;
        AddressW = Clamp;
        MagFilter = Linear;
        MinFilter = Linear;
        MipFilter = Point;
        ComparisonFunc = Less;
        MaxAnisotropy = 16;
        ReductionType = Comparison;
    };    
    
    struct Constants
    {
        float2 m_screenSize;
    };    
    
    Constants m_constantData;
    Texture2DArray<float> m_directionalLightShadowmap;   
    Texture2DArray<float> m_directionalLightExponentialShadowmap;    
    Texture2D<float> m_depth;
}

#include <Atom/RPI/ShaderResourceGroups/DefaultDrawSrg.azsli>

class DirectionalLightShadow
{
    struct DebugInfo
    {
        uint m_cascadeIndex; // cascade index where lit ratio determined.
        bool m_usePcfFallback;
    };

    // This outputs the coordinate in shadowmap Texture space of the given point.
    void GetShadowCoords(
        uint lightIndex,
        float3 worldPosition,
        float3 worldNormal,
        out float3 shadowCoords[ViewSrg::MaxCascadeCount])
    {
        const float shadowBias = ViewSrg::m_directionalLightShadows[lightIndex].m_shadowBias;

        const float4x4 lightViewToShadowmapMatrices[ViewSrg::MaxCascadeCount] = ViewSrg::m_directionalLightShadows[lightIndex].m_lightViewToShadowmapMatrices;
        const float4x4 worldToLightViewMatrices[ViewSrg::MaxCascadeCount] = ViewSrg::m_directionalLightShadows[lightIndex].m_worldToLightViewMatrices;

        const uint cascadeCount = ViewSrg::m_directionalLightShadows[lightIndex].m_cascadeCount;
        const float3 shadowOffset = ComputeNormalShadowOffset(ViewSrg::m_directionalLightShadows[lightIndex].m_normalShadowBias, worldNormal, ViewSrg::m_directionalLightShadows[lightIndex].m_shadowmapSize);

        for (uint index = 0; index < cascadeCount; ++index)
        {        
            float4 lightSpacePos = mul(worldToLightViewMatrices[index], float4(worldPosition + shadowOffset, 1.));
            lightSpacePos.z += shadowBias;
            
            const float4 clipSpacePos = mul(lightViewToShadowmapMatrices[index], lightSpacePos);                
            shadowCoords[index] = clipSpacePos.xyz / clipSpacePos.w;
        }
    }



    bool2 IsShadowed(float3 shadowCoord, uint indexOfCascade)
    {
        static const float PixelMargin = 1.5; // avoiding artifact between cascade levels.
        static const float DepthMargin = 1e-8; // avoiding artifact when near depth bounds.

        // size is the shadowap's width and height.
        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;

        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        Texture2DArray<float> shadowmap = PassSrg::m_directionalLightShadowmap;

        [branch]
        if (shadowCoord.x >= 0. && shadowCoord.x * size < size - PixelMargin &&
            shadowCoord.y >= 0. && shadowCoord.y * size < size - PixelMargin)
        {
            const float3 coord = float3(shadowCoord.xy, indexOfCascade);
            const float depthInShadowmap = shadowmap.Sample(PassSrg::LinearSampler, coord).r;
            // Test the case where the shadowed pixel is nearer than the maximal depth
            // of the cascade.  Otherwise, escalate the next cascade.
            if (shadowCoord.z < 1. - DepthMargin)
            {
                const float depthDiff = shadowCoord.z - depthInShadowmap;
                return bool2(true, (depthDiff > m_slopeBias[indexOfCascade]));
            }
        }
        return bool2(false, false);
    }
    
    float GetVisibilityFromLightNoFilter()
    {       
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        for (uint indexOfCascade = 0; indexOfCascade < cascadeCount; ++indexOfCascade)
        {
            const bool2 checkedShadowed = IsShadowed(
                m_shadowCoords[indexOfCascade],
                indexOfCascade);
            if (checkedShadowed.x)
            {
                m_debugInfo.m_cascadeIndex = indexOfCascade;
                return checkedShadowed.y ? 0. : 1.;
            }
        }
        m_debugInfo.m_cascadeIndex = cascadeCount;
        return 1.;
    }    

    float SamplePcfBicubic(float3 shadowCoord, uint indexOfCascade)
    {
        const uint filteringSampleCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_filteringSampleCount;
        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;
        
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        Texture2DArray<float> shadowmap = PassSrg::m_directionalLightShadowmap;

        SampleShadowMapBicubicParameters param;
        param.shadowMap = shadowmap;
        param.shadowPos = float3(shadowCoord.xy, indexOfCascade);
        param.shadowMapSize = size;
        param.invShadowMapSize = rcp(size); 
        param.comparisonValue = shadowCoord.z;
        param.samplerState = PassSrg::m_hwPcfSampler;
        param.receiverPlaneDepthBias = 0;//o_directional_shadow_receiver_plane_bias_enable ? ComputeReceiverPlaneDepthBias(m_shadowPosDX[indexOfCascade], m_shadowPosDY[indexOfCascade]) : 0;
        
        [branch]     
        if (filteringSampleCount <= 4)       
        {
            return SampleShadowMapBicubic_4Tap(param);
        }
        else if (filteringSampleCount <= 9)
        {
            return SampleShadowMapBicubic_9Tap(param);
        }
        else
        {
            return SampleShadowMapBicubic_16Tap(param);
        }
    }
     
    float GetVisibilityFromLightPcf()
    {   
        static const float PixelMargin = 1.5; // avoiding artifact between cascade levels.
        static const float DepthMargin = 1e-8; // avoiding artifact when near depth bounds.

        bool cascadeFound = false;
        int currentCascadeIndex = 0;

        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        for (uint indexOfCascade = 0; indexOfCascade < cascadeCount; ++indexOfCascade)
        {
            const float3 shadowCoord = m_shadowCoords[indexOfCascade];
            
            if (shadowCoord.x >= 0. && shadowCoord.x * size < size - PixelMargin &&
                shadowCoord.y >= 0. && shadowCoord.y * size < size - PixelMargin && 
                shadowCoord.z < 1. - DepthMargin)
            {
                currentCascadeIndex = m_debugInfo.m_cascadeIndex = indexOfCascade;
      //          currentCascadeIndex = indexOfCascade;
                cascadeFound = true;
                break;
            }
        }

        [branch]
        if (cascadeFound)
        {
            float lit = SamplePcfBicubic(m_shadowCoords[currentCascadeIndex], currentCascadeIndex);
            /*
            if(o_blend_between_cascades_enable) 
            {  
                const float blendBetweenCascadesAmount = CalculateCascadeBlendAmount(m_shadowCoords[currentCascadeIndex].xyz);

                const int nextCascadeIndex = currentCascadeIndex + 1;
                [branch]
                if (blendBetweenCascadesAmount < 1.0f && nextCascadeIndex < cascadeCount)
                {
                    const float nextLit = SamplePcfBicubic(m_shadowCoords[nextCascadeIndex], nextCascadeIndex);
                    lit = lerp(nextLit, lit, blendBetweenCascadesAmount);             
                }
            } 
*/
            return lit;
        }

        m_debugInfo.m_cascadeIndex = cascadeCount;
        return 1.;
    } 
            
    float GetVisibilityFromLightEsm()
    {
        const uint size = ViewSrg::m_directionalLightShadows[m_lightIndex].m_shadowmapSize;
        const uint cascadeCount = ViewSrg::m_directionalLightShadows[m_lightIndex].m_cascadeCount;
        Texture2DArray<float> shadowmap = PassSrg::m_directionalLightShadowmap;
        Texture2DArray<float> expShadowmap = PassSrg::m_directionalLightExponentialShadowmap;

        for (uint indexOfCascade = 0; indexOfCascade < cascadeCount; ++indexOfCascade)
        {
            const float3 shadowCoord = m_shadowCoords[indexOfCascade];
            const float distanceMin = ViewSrg::m_esmsDirectional[indexOfCascade].m_lightDistanceOfCameraViewFrustum;
            bool2 checkedShadowed = IsShadowed(shadowCoord, indexOfCascade);
            const float depthDiff = shadowCoord.z - distanceMin;
        
            [branch]
            if (checkedShadowed.x && depthDiff >= 0)
            {
                const float distanceWithinCameraView = depthDiff / (1. - distanceMin);
                const float3 coord = float3(shadowCoord.xy, indexOfCascade);
                const float occluder = expShadowmap.Sample(PassSrg::LinearSampler, coord).r;                        
                const float exponent = -EsmExponentialShift * (distanceWithinCameraView - occluder);
                const float ratio = exp(exponent);

                m_debugInfo.m_cascadeIndex = indexOfCascade;
                return saturate(ratio);
            }
        }

        m_debugInfo.m_cascadeIndex = cascadeCount;
        return 1.;
    }

        
    float3 m_shadowCoords[ViewSrg::MaxCascadeCount];
    float m_slopeBias[ViewSrg::MaxCascadeCount];
    uint m_lightIndex;
    DebugInfo m_debugInfo;    
};





PSOutput MainPS(VSOutput IN)
{
    DirectionalLightShadow directionalLightShadow;

    const uint lightIndex = 0;
    float3 coord = 0;
    float v = PassSrg::m_directionalLightShadowmap.Sample(PassSrg::LinearSampler, coord);
    const float shadowBias = ViewSrg::m_directionalLightShadows[lightIndex].m_shadowBias;
    const float zDepth = PassSrg::m_depth.Sample(PassSrg::LinearSampler, IN.m_texCoord);

    float3 surfacePosWS = WorldPositionFromDepthBuffer(PassSrg::m_constantData.m_screenSize, zDepth, IN.m_position.xy).xyz;
    
    const float distanceFromOrigin = length(surfacePosWS);
    const float3 worldNormal = float3(0,0,1);
    
    directionalLightShadow.GetShadowCoords(lightIndex, surfacePosWS, worldNormal, directionalLightShadow.m_shadowCoords);
    float shadow = directionalLightShadow.GetVisibilityFromLightPcf(); // GetVisibilityFromLightNoFilter
    shadow = directionalLightShadow.GetVisibilityFromLightEsm();
    
    PSOutput OUT;
    OUT.m_color.rgb = shadow;

    return OUT; 
}


