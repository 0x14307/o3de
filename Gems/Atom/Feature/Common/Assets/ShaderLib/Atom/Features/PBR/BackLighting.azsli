/*
 * Copyright (c) Contributors to the Open 3D Engine Project.
 * For complete copyright and license terms please see the LICENSE at the root of this distribution.
 *
 * SPDX-License-Identifier: Apache-2.0 OR MIT
 *
 */

#pragma once

// ------------------------------------------------------------------------------
// NOTE: The following must be included or defined before including this file:
//       - Surface          - LightingData
// ---------------------------------------------------------------------------------

#include <Atom/Features/PBR/LightingOptions.azsli>

// Analytical integation (approximation) of diffusion profile over radius, could be replaced by other pre integrated kernels
// such as sum of Gaussian (see T(s))
float3 TransmissionKernel(float t, float3 s)
{
    float3 exponent = s * t;
    return 0.25 * (1.0 / exp(exponent) + 3.0 / exp(exponent / 3.0));
}

// [specific profile for SKIN (not used ATM, replaced by TransmissionKernel)]
// Analytical integation (approximation) of diffusion profile over radius, could be precomputed in a LUT
float3 T(float s) 
{
    // dipoles and multipoles are approximated with sums of a small number of Gaussians with variable weights and variances
    return float3(0.233, 0.455, 0.649) * exp(-s*s/0.0064) +
    float3(0.1, 0.336, 0.344) * exp(-s*s/0.0484) +
    float3(0.118, 0.198, 0.0) * exp(-s*s/0.187) +
    float3(0.113, 0.007, 0.007) * exp(-s*s/0.567) +
    float3(0.358, 0.004, 0.0) * exp(-s*s/1.99) +
    float3(0.078, 0.0, 0.0) * exp(-s*s/7.41);
}

float3 GetBackLighting(Surface surface, LightingData lightingData, float3 lightIntensity, float3 dirToLight, float transmissionDistance, float attenuationDistance)
{
    float3 result = float3(0.0, 0.0, 0.0);
    float thickness = 0.0; 
    float4 transmissionParams = surface.transmission.transmissionParams;

    switch(o_transmission_mode)
    {
        case TransmissionMode::None:
            break;

        case TransmissionMode::ThickObject: 
            // Thick object mode, using back lighting approximation proposed by Brisebois B. C. and Bouchard M. 2011
            // https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/

            {
                thickness = max(transmissionDistance, surface.transmission.thickness);
                float transmittance = pow( saturate( dot( lightingData.dirToCamera, -normalize( dirToLight + surface.normal * transmissionParams.z ) ) ), transmissionParams.y ) * transmissionParams.w;
                float lamberAttenuation = exp(-thickness * transmissionParams.x) * saturate(1.0 - thickness);
                result = transmittance * lamberAttenuation * lightIntensity;
            }
            break;

        case TransmissionMode::ThinObject:
            // Thin object mode, based on Jimenez J. et al, 2010, "Real-Time Realistic Skin Translucency"
            // http://www.iryoku.com/translucency/downloads/Real-Time-Realistic-Skin-Translucency.pdf
            
            {
                // transmissionDistance < 0.0f means shadows are not enabled --> avoid unnecessary computation
                if (transmissionDistance < 0.0f)
                {
                    break;
                }

                // Irradiance arround surface point. 
                // Increase angle of influence (angle(N,L) -> angle(N,L) + acos(transmissionNdLBias)) to smooth transition regions
                float3 E = surface.albedo * max(lightingData.transmissionNdLBias + dot(-surface.normal, dirToLight),0.0);

                // Transmission distance modulated by hardcoded constant (could be exposed as a weight of scattering distance for transmission)
                float s = transmissionDistance * 100.0;
                
                // Use scattering color to weight thin object transmission color
                const float3 invScattering = rcp(transmissionParams.xyz);
                
                // Albedo at front (surface point) is used to approximate irradiance at the back of the object
                // See observation 4 in [Jimenez J. et al, 2010] 
                result = TransmissionKernel(s, invScattering) * lightIntensity * E * transmissionParams.w;
                
                // Alternative specific to skin translucency
                // result = T(s) * lightIntensity * surface.albedo * E * transmissionParams.w;
                
                // Distance attenuation applied to hide artifacts due to low-res projected areas onto shadowmaps (might need some work in the future)
                result *= 1.0 / pow(max(1.0, sqrt(attenuationDistance)), lightingData.distanceAttenuation + 1.0);
            }
            break;
    }
    
    return result;
}

